'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = require('path');
var path__default = _interopDefault(path);
var ts = require('typescript');

function getCodeFrame() {
    try {
        const { codeFrameColumns } = require("@babel/code-frame");
        return codeFrameColumns;
    }
    catch (_a) { }
    // istanbul ignore next
    return undefined;
}
function getLocation(node) {
    const sourceFile = node.getSourceFile();
    const start = sourceFile.getLineAndCharacterOfPosition(node.getStart());
    const end = sourceFile.getLineAndCharacterOfPosition(node.getEnd());
    return {
        start: { line: start.line + 1, column: start.character + 1 },
        end: { line: end.line + 1, column: end.character + 1 },
    };
}
function frameNodes(nodes, messages = []) {
    const codeFrame = getCodeFrame();
    const sourceFile = nodes[0].getSourceFile();
    const code = sourceFile.getFullText();
    let output = "";
    let lastLine;
    // oh jesus, why does @babel/code-frame not support this out of the box?
    for (const [i, node] of nodes.entries()) {
        const message = messages[i];
        // istanbul ignore else
        const location = getLocation(node);
        if (codeFrame) {
            const nextLocation = nodes[i + 1] && getLocation(nodes[i + 1]);
            const linesAbove = typeof lastLine === "number" ? location.start.line - lastLine - 1 : 2;
            const linesBelow = nextLocation ? nextLocation.start.line - location.end.line - 1 : 3;
            output +=
                "\n" +
                    codeFrame(code, location, {
                        highlightCode: true,
                        message,
                        linesAbove,
                        linesBelow,
                    });
            lastLine = location.end.line + linesBelow;
        }
        else {
            output += `\n${location.start.line}:${location.start.column}: \`${node.getFullText().trim()}\` <- ${message}`;
        }
    }
    return output;
}
class UnsupportedSyntaxError extends Error {
    constructor(node, message = "Syntax not yet supported") {
        super(`${message}\n${frameNodes([node])}`);
    }
}

class NamespaceFixer {
    constructor(sourceFile) {
        this.sourceFile = sourceFile;
    }
    findNamespaces() {
        const namespaces = [];
        const itemTypes = {};
        for (const node of this.sourceFile.statements) {
            if (ts.isClassDeclaration(node)) {
                itemTypes[node.name.getText()] = "class";
            }
            else if (ts.isFunctionDeclaration(node)) {
                itemTypes[node.name.getText()] = "function";
            }
            else if (ts.isInterfaceDeclaration(node)) {
                itemTypes[node.name.getText()] = "interface";
            }
            else if (ts.isModuleDeclaration(node)) {
                itemTypes[node.name.getText()] = "namespace";
            }
            else if (ts.isEnumDeclaration(node)) {
                itemTypes[node.name.getText()] = "enum";
            }
            if (!ts.isVariableStatement(node)) {
                continue;
            }
            const { declarations } = node.declarationList;
            if (declarations.length !== 1) {
                continue;
            }
            const decl = declarations[0];
            const name = decl.name.getText();
            if (!decl.initializer || !ts.isCallExpression(decl.initializer)) {
                itemTypes[name] = "var";
                continue;
            }
            const obj = decl.initializer.arguments[0];
            if (!decl.initializer.expression.getFullText().includes("/*#__PURE__*/Object.freeze") ||
                !ts.isObjectLiteralExpression(obj)) {
                continue;
            }
            const exports = [];
            for (const prop of obj.properties) {
                if (!ts.isPropertyAssignment(prop) ||
                    !ts.isIdentifier(prop.name) ||
                    (prop.name.text !== "__proto__" && !ts.isIdentifier(prop.initializer))) {
                    throw new UnsupportedSyntaxError(prop, "Expected a property assignment");
                }
                if (prop.name.text === "__proto__") {
                    continue;
                }
                exports.push({
                    exportedName: prop.name.getText(),
                    localName: prop.initializer.getText(),
                });
            }
            // sort in reverse order, since we will do string manipulation
            namespaces.unshift({
                name,
                exports,
                location: {
                    start: node.getStart(),
                    end: node.getEnd(),
                },
            });
        }
        return { namespaces, itemTypes };
    }
    fix() {
        let code = this.sourceFile.getFullText();
        const { namespaces, itemTypes } = this.findNamespaces();
        for (const ns of namespaces) {
            const codeAfter = code.slice(ns.location.end);
            code = code.slice(0, ns.location.start);
            for (const { exportedName, localName } of ns.exports) {
                if (exportedName === localName) {
                    const type = itemTypes[localName];
                    if (type === "interface") {
                        // an interface is just a type
                        code += `type ${ns.name}_${exportedName} = ${localName};\n`;
                    }
                    else if (type === "enum" || type === "class") {
                        // enums and classes are both types and values
                        code += `type ${ns.name}_${exportedName} = ${localName};\n`;
                        code += `declare const ${ns.name}_${exportedName}: typeof ${localName};\n`;
                    }
                    else {
                        // functions and vars are just values
                        code += `declare const ${ns.name}_${exportedName}: typeof ${localName};\n`;
                    }
                }
            }
            code += `declare namespace ${ns.name} {\n`;
            code += `  export {\n`;
            for (const { exportedName, localName } of ns.exports) {
                if (exportedName === localName) {
                    code += `    ${ns.name}_${exportedName} as ${exportedName},\n`;
                }
                else {
                    code += `    ${localName} as ${exportedName},\n`;
                }
            }
            code += `  };\n`;
            code += `}`;
            code += codeAfter;
        }
        return code;
    }
}

const dts = ".d.ts";
const formatHost = {
    getCurrentDirectory: () => ts.sys.getCurrentDirectory(),
    getNewLine: () => ts.sys.newLine,
    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? f => f : f => f.toLowerCase(),
};
const OPTIONS_OVERRIDE = {
    // Ensure ".d.ts" modules are generated
    declaration: true,
    // Skip ".js" generation
    emitDeclarationOnly: true,
    // Skip code generation when error occurs
    noEmitOnError: true,
    // Avoid extra work
    checkJs: false,
    declarationMap: false,
    skipLibCheck: true,
    // Ensure TS2742 errors are visible
    preserveSymlinks: true,
    // Ensure we can parse the latest code
    target: ts.ScriptTarget.ESNext,
};
function getCompilerOptions(input) {
    let dirName = path.dirname(input);
    const configPath = ts.findConfigFile(path.dirname(input), ts.sys.fileExists);
    if (!configPath) {
        return { dirName, compilerOptions: Object.assign({}, OPTIONS_OVERRIDE) };
    }
    dirName = path.dirname(configPath);
    const { config, error } = ts.readConfigFile(configPath, ts.sys.readFile);
    if (error) {
        console.error(ts.formatDiagnostic(error, formatHost));
        return { dirName, compilerOptions: Object.assign({}, OPTIONS_OVERRIDE) };
    }
    const { options, errors } = ts.parseJsonConfigFileContent(config, ts.sys, dirName);
    if (errors.length) {
        console.error(ts.formatDiagnostics(errors, formatHost));
        return { dirName, compilerOptions: Object.assign({}, OPTIONS_OVERRIDE) };
    }
    return {
        dirName,
        compilerOptions: Object.assign(Object.assign({}, options), OPTIONS_OVERRIDE),
    };
}
function createPrograms(input) {
    const programs = [];
    let inputs = [];
    let dirName = "";
    let compilerOptions = {};
    for (let main of input) {
        if (main.endsWith(dts)) {
            continue;
        }
        main = path.resolve(main);
        const options = getCompilerOptions(main);
        if (!inputs.length) {
            inputs.push(main);
            ({ dirName, compilerOptions } = options);
            continue;
        }
        if (options.dirName === dirName) {
            inputs.push(main);
        }
        else {
            const host = ts.createCompilerHost(compilerOptions, true);
            const program = ts.createProgram(inputs, compilerOptions, host);
            programs.push(program);
            inputs = [main];
            ({ dirName, compilerOptions } = options);
        }
    }
    if (inputs.length) {
        const host = ts.createCompilerHost(compilerOptions, true);
        const program = ts.createProgram(inputs, compilerOptions, host);
        programs.push(program);
    }
    return programs;
}

const MARKER = "0";
let IDs = 1;
/**
 * Create a new `Program` for the given `node`:
 */
function createProgram(node) {
    return withStartEnd({
        type: "Program",
        sourceType: "module",
        body: [],
    }, node);
}
/**
 * Create a default export for `id`:
 * `export default id`
 */
function createDefaultExport(node, range) {
    return withStartEnd({
        type: "ExportDefaultDeclaration",
        declaration: createIdentifier(node),
    }, range);
}
/**
 * Create an export for `id`:
 * `export { id }`
 */
function createExport(node, range) {
    const id = createIdentifier(node);
    return withStartEnd({
        type: "ExportNamedDeclaration",
        declaration: null,
        specifiers: [
            {
                type: "ExportSpecifier",
                exported: id,
                local: id,
            },
        ],
    }, range);
}
/**
 * Creates a reference to `id`:
 * `_ = ${id}`
 */
function createReference(id) {
    return {
        type: "AssignmentPattern",
        left: {
            type: "Identifier",
            name: String(IDs++),
        },
        right: id,
    };
}
function createIdentifier(node) {
    return withStartEnd({
        type: "Identifier",
        name: node.getText(),
    }, {
        start: node.getStart(),
        end: node.getEnd(),
    });
}
/**
 * Create a new Scope which is always included
 * `(function (_ = MARKER) {})()`
 */
function createIIFE(range) {
    const fn = withStartEnd({
        type: "FunctionExpression",
        id: null,
        params: [],
        body: { type: "BlockStatement", body: [] },
    }, range);
    const iife = withStartEnd({
        type: "ExpressionStatement",
        expression: {
            type: "CallExpression",
            callee: { type: "Identifier", name: String(IDs++) },
            arguments: [fn],
        },
    }, range);
    return { fn, iife };
}
/**
 * Create a new Declaration and Scope for `id`:
 * `function ${id}(_ = MARKER) {}`
 */
function createDeclaration(id, range) {
    return withStartEnd({
        type: "FunctionDeclaration",
        id: withStartEnd({
            type: "Identifier",
            name: ts.idText(id),
        }, { start: id.getStart(), end: id.getEnd() }),
        params: [],
        body: { type: "BlockStatement", body: [] },
    }, range);
}
function convertExpression(node) {
    if (ts.isLiteralExpression(node)) {
        return { type: "Literal", value: node.text };
    }
    if (ts.isPropertyAccessExpression(node)) {
        return withStartEnd({
            type: "MemberExpression",
            computed: false,
            object: convertExpression(node.expression),
            property: convertExpression(node.name),
        }, {
            start: node.expression.getStart(),
            end: node.name.getEnd(),
        });
    }
    // istanbul ignore else
    if (ts.isIdentifier(node)) {
        return createIdentifier(node);
    }
    else {
        throw new UnsupportedSyntaxError(node);
    }
}
/**
 * Mark the nested `range` to be removed, by creating dead code:
 * `_ = () => {MARKER}`
 */
function removeNested(range) {
    return createReference({
        type: "FunctionExpression",
        id: null,
        body: withStartEnd({
            type: "BlockStatement",
            body: [
                withStartEnd({
                    type: "ExpressionStatement",
                    expression: { type: "Identifier", name: MARKER },
                }, range),
            ],
        }, {
            start: getStart(range) - 1,
            end: range.end + 1,
        }),
        params: [],
    });
}
function getStart({ start, pos }) {
    return typeof start === "number" ? start : pos || 0;
}
function withStartEnd(node, range) {
    return Object.assign(node, {
        start: getStart(range),
        end: range.end,
    });
}
function matchesModifier(node, flags) {
    const nodeFlags = ts.getCombinedModifierFlags(node);
    return (nodeFlags & flags) === flags;
}

const IGNORE_TYPENODES = new Set([
    ts.SyntaxKind.LiteralType,
    ts.SyntaxKind.VoidKeyword,
    ts.SyntaxKind.UnknownKeyword,
    ts.SyntaxKind.AnyKeyword,
    ts.SyntaxKind.BooleanKeyword,
    ts.SyntaxKind.NumberKeyword,
    ts.SyntaxKind.StringKeyword,
    ts.SyntaxKind.ObjectKeyword,
    ts.SyntaxKind.NullKeyword,
    ts.SyntaxKind.UndefinedKeyword,
    ts.SyntaxKind.SymbolKeyword,
    ts.SyntaxKind.NeverKeyword,
    ts.SyntaxKind.ThisKeyword,
    ts.SyntaxKind.ThisType,
    ts.SyntaxKind.BigIntKeyword,
]);
class DeclarationScope {
    constructor({ id, range, transformer }) {
        /**
         * As we walk the AST, we need to keep track of type variable bindings that
         * shadow the outer identifiers. To achieve this, we keep a stack of scopes,
         * represented as Sets of variable names.
         */
        this.scopes = [];
        this.transformer = transformer;
        if (id) {
            this.declaration = createDeclaration(id, range);
        }
        else {
            const { iife, fn } = createIIFE(range);
            this.iife = iife;
            this.declaration = fn;
        }
    }
    pushScope() {
        this.scopes.push(new Set());
    }
    popScope(n = 1) {
        for (let i = 0; i < n; i++) {
            this.scopes.pop();
        }
    }
    pushTypeVariable(id) {
        const name = id.getText();
        this.scopes[this.scopes.length - 1].add(name);
    }
    pushRaw(expr) {
        this.declaration.params.push(expr);
    }
    pushReference(id) {
        let name;
        // We convert references from TS AST to ESTree
        // to hand them off to rollup.
        // This means we have to check the left-most identifier inside our scope
        // tree and avoid to create the reference in that case
        if (id.type === "Identifier") {
            name = id.name;
        }
        else if (id.type === "MemberExpression") {
            if (id.object.type === "Identifier") {
                name = id.object.name;
            }
        }
        if (name) {
            for (const scope of this.scopes) {
                if (scope.has(name)) {
                    return;
                }
            }
        }
        this.pushRaw(createReference(id));
    }
    pushIdentifierReference(id) {
        this.pushReference(createIdentifier(id));
    }
    /**
     * This will fix up the modifiers of a declaration.
     * We want to remove `export (default)?` modifiers, and in that case add a
     * missing `declare`. All the others should be untouched.
     */
    fixModifiers(node) {
        if (!node.modifiers) {
            return;
        }
        const modifiers = [];
        let hasDeclare = false;
        let start = Infinity;
        let end = 0;
        for (const mod of node.modifiers) {
            if (mod.kind !== ts.SyntaxKind.ExportKeyword && mod.kind !== ts.SyntaxKind.DefaultKeyword) {
                modifiers.push(mod.getText());
            }
            if (mod.kind === ts.SyntaxKind.DeclareKeyword) {
                hasDeclare = true;
            }
            start = Math.min(start, mod.getStart());
            end = Math.max(end, mod.getEnd());
        }
        // function and class *must* have a `declare` modifier
        if (!hasDeclare && (ts.isClassDeclaration(node) || ts.isFunctionDeclaration(node))) {
            modifiers.unshift("declare");
        }
        const newModifiers = modifiers.join(" ");
        if (!newModifiers && end) {
            end += 1;
        }
        const middle = start + newModifiers.length;
        this.pushRaw(removeNested({ start: middle, end }));
        if (newModifiers) {
            this.transformer.fixups.push({
                range: { start, end: middle },
                replaceWith: newModifiers,
            });
        }
    }
    convertEntityName(node) {
        if (ts.isIdentifier(node)) {
            return createIdentifier(node);
        }
        return withStartEnd({
            type: "MemberExpression",
            computed: false,
            object: this.convertEntityName(node.left),
            property: createIdentifier(node.right),
        }, 
        // TODO: clean up all the `start` handling!
        { start: node.getStart(), end: node.end });
    }
    convertPropertyAccess(node) {
        // hm, we only care about property access expressions here…
        if (ts.isIdentifier(node.expression)) {
            return createIdentifier(node.expression);
        }
        if (ts.isPropertyAccessExpression(node.expression)) {
            return withStartEnd({
                type: "MemberExpression",
                computed: false,
                object: this.convertPropertyAccess(node.expression),
                property: createIdentifier(node.name),
            }, 
            // TODO: clean up all the `start` handling!
            { start: node.getStart(), end: node.end });
        }
        throw new UnsupportedSyntaxError(node.expression);
    }
    convertComputedPropertyName(node) {
        if (!node.name || !ts.isComputedPropertyName(node.name)) {
            return;
        }
        const { expression } = node.name;
        if (ts.isIdentifier(expression)) {
            return this.pushReference(createIdentifier(expression));
        }
        if (ts.isPropertyAccessExpression(expression)) {
            return this.pushReference(this.convertPropertyAccess(expression));
        }
        throw new UnsupportedSyntaxError(expression);
    }
    convertParametersAndType(node) {
        this.convertComputedPropertyName(node);
        const typeVariables = this.convertTypeParameters(node.typeParameters);
        for (const param of node.parameters) {
            this.convertTypeNode(param.type);
        }
        this.convertTypeNode(node.type);
        this.popScope(typeVariables);
    }
    convertHeritageClauses(node) {
        for (const heritage of node.heritageClauses || []) {
            for (const type of heritage.types) {
                this.pushReference(convertExpression(type.expression));
                for (const arg of type.typeArguments || []) {
                    this.convertTypeNode(arg);
                }
            }
        }
    }
    convertMembers(members) {
        for (const node of members) {
            if (ts.isPropertyDeclaration(node) || ts.isPropertySignature(node) || ts.isIndexSignatureDeclaration(node)) {
                this.convertComputedPropertyName(node);
                this.convertTypeNode(node.type);
                continue;
            }
            // istanbul ignore else
            if (ts.isMethodDeclaration(node) ||
                ts.isMethodSignature(node) ||
                ts.isConstructorDeclaration(node) ||
                ts.isConstructSignatureDeclaration(node) ||
                ts.isCallSignatureDeclaration(node) ||
                ts.isGetAccessorDeclaration(node) ||
                ts.isSetAccessorDeclaration(node)) {
                this.convertParametersAndType(node);
            }
            else {
                throw new UnsupportedSyntaxError(node);
            }
        }
    }
    convertTypeParameters(params) {
        if (!params) {
            return 0;
        }
        for (const node of params) {
            this.convertTypeNode(node.constraint);
            this.convertTypeNode(node.default);
            this.pushScope();
            this.pushTypeVariable(node.name);
        }
        return params.length;
    }
    convertTypeNode(node) {
        if (!node) {
            return;
        }
        if (IGNORE_TYPENODES.has(node.kind)) {
            return;
        }
        if (ts.isTypeReferenceNode(node)) {
            this.pushReference(this.convertEntityName(node.typeName));
            for (const arg of node.typeArguments || []) {
                this.convertTypeNode(arg);
            }
            return;
        }
        if (ts.isTypeLiteralNode(node)) {
            return this.convertMembers(node.members);
        }
        if (ts.isArrayTypeNode(node)) {
            return this.convertTypeNode(node.elementType);
        }
        if (ts.isTupleTypeNode(node)) {
            for (const type of node.elementTypes) {
                this.convertTypeNode(type);
            }
            return;
        }
        if (ts.isParenthesizedTypeNode(node) || ts.isTypeOperatorNode(node) || ts.isTypePredicateNode(node)) {
            return this.convertTypeNode(node.type);
        }
        if (ts.isUnionTypeNode(node) || ts.isIntersectionTypeNode(node)) {
            for (const type of node.types) {
                this.convertTypeNode(type);
            }
            return;
        }
        if (ts.isMappedTypeNode(node)) {
            const { typeParameter, type } = node;
            this.convertTypeNode(typeParameter.constraint);
            this.pushScope();
            this.pushTypeVariable(node.typeParameter.name);
            this.convertTypeNode(type);
            this.popScope();
            return;
        }
        if (ts.isConditionalTypeNode(node)) {
            this.convertTypeNode(node.checkType);
            this.pushScope();
            this.convertTypeNode(node.extendsType);
            this.convertTypeNode(node.trueType);
            this.convertTypeNode(node.falseType);
            this.popScope();
            return;
        }
        if (ts.isIndexedAccessTypeNode(node)) {
            this.convertTypeNode(node.objectType);
            this.convertTypeNode(node.indexType);
            return;
        }
        if (ts.isFunctionOrConstructorTypeNode(node)) {
            this.convertParametersAndType(node);
            return;
        }
        if (ts.isImportTypeNode(node)) {
            this.convertImportTypeNode(node);
            return;
        }
        if (ts.isTypeQueryNode(node)) {
            this.pushReference(this.convertEntityName(node.exprName));
            return;
        }
        if (ts.isTypeNode(node) && node.kind === ts.SyntaxKind.RestType) {
            this.convertTypeNode(node.type);
            return;
        }
        if (ts.isTypeNode(node) && node.kind === ts.SyntaxKind.OptionalType) {
            this.convertTypeNode(node.type);
            return;
        }
        // istanbul ignore else
        if (ts.isInferTypeNode(node)) {
            this.pushTypeVariable(node.typeParameter.name);
            return;
        }
        else {
            throw new UnsupportedSyntaxError(node);
        }
    }
    // For import type nodes of the form
    // `import("./foo").Bar`
    // we create the following ESTree equivalent:
    // 1. `import * as _ from "./foo";` on the toplevel
    // 2. `_.Bar` in our declaration scope
    convertImportTypeNode(node) {
        // istanbul ignore if
        if (!ts.isLiteralTypeNode(node.argument) || !ts.isStringLiteral(node.argument.literal)) {
            throw new UnsupportedSyntaxError(node, "inline imports should have a literal argument");
        }
        const fileId = node.argument.literal.text;
        const start = node.getStart() + (node.isTypeOf ? "typeof ".length : 0);
        const range = {
            start,
            end: (node.qualifier ? node.qualifier : node).getEnd(),
        };
        const importId = this.transformer.addFixupLocation(range);
        const importIdRef = withStartEnd({
            type: "Identifier",
            name: importId,
        }, range);
        this.transformer.unshiftStatement({
            type: "ImportDeclaration",
            specifiers: [
                {
                    type: "ImportNamespaceSpecifier",
                    local: { type: "Identifier", name: importId },
                },
            ],
            source: { type: "Literal", value: fileId },
        });
        if (node.qualifier && ts.isIdentifier(node.qualifier)) {
            this.pushReference(withStartEnd({
                type: "MemberExpression",
                computed: false,
                object: importIdRef,
                property: createIdentifier(node.qualifier),
            }, range));
        }
        else {
            // we definitely need to do some string manipulation on the source code,
            // since rollup will not touch the `import("...")` bit at all.
            // also, for *internal* namespace references, we have the same problem
            // as with re-exporting references… -_-
            this.pushReference(importIdRef);
        }
    }
    convertNamespace(node) {
        this.pushScope();
        // istanbul ignore if
        if (!node.body || !ts.isModuleBlock(node.body)) {
            throw new UnsupportedSyntaxError(node, `namespace must have a "ModuleBlock" body.`);
        }
        const { statements } = node.body;
        // first, hoist all the declarations for correct shadowing
        for (const stmt of statements) {
            if (ts.isEnumDeclaration(stmt) ||
                ts.isFunctionDeclaration(stmt) ||
                ts.isClassDeclaration(stmt) ||
                ts.isInterfaceDeclaration(stmt) ||
                ts.isTypeAliasDeclaration(stmt) ||
                ts.isModuleDeclaration(stmt)) {
                // istanbul ignore else
                if (stmt.name && ts.isIdentifier(stmt.name)) {
                    this.pushTypeVariable(stmt.name);
                }
                else {
                    throw new UnsupportedSyntaxError(stmt, `non-Identifier name not supported`);
                }
                continue;
            }
            if (ts.isVariableStatement(stmt)) {
                for (const decl of stmt.declarationList.declarations) {
                    // istanbul ignore else
                    if (ts.isIdentifier(decl.name)) {
                        this.pushTypeVariable(decl.name);
                    }
                    else {
                        throw new UnsupportedSyntaxError(decl, `non-Identifier name not supported`);
                    }
                }
                continue;
            }
            // istanbul ignore else
            if (ts.isExportDeclaration(stmt)) ;
            else {
                throw new UnsupportedSyntaxError(stmt, `namespace child (hoisting) not supported yet`);
            }
        }
        // and then walk all the children like normal…
        for (const stmt of statements) {
            if (ts.isVariableStatement(stmt)) {
                for (const decl of stmt.declarationList.declarations) {
                    if (decl.type) {
                        this.convertTypeNode(decl.type);
                    }
                }
                continue;
            }
            if (ts.isFunctionDeclaration(stmt)) {
                this.convertParametersAndType(stmt);
                continue;
            }
            if (ts.isInterfaceDeclaration(stmt) || ts.isClassDeclaration(stmt)) {
                const typeVariables = this.convertTypeParameters(stmt.typeParameters);
                this.convertHeritageClauses(stmt);
                this.convertMembers(stmt.members);
                this.popScope(typeVariables);
                continue;
            }
            if (ts.isTypeAliasDeclaration(stmt)) {
                const typeVariables = this.convertTypeParameters(stmt.typeParameters);
                this.convertTypeNode(stmt.type);
                this.popScope(typeVariables);
                continue;
            }
            if (ts.isModuleDeclaration(stmt)) {
                this.convertNamespace(stmt);
                continue;
            }
            if (ts.isEnumDeclaration(stmt)) {
                // noop
                continue;
            }
            // istanbul ignore else
            if (ts.isExportDeclaration(stmt)) {
                if (stmt.exportClause) {
                    for (const decl of stmt.exportClause.elements) {
                        const id = decl.propertyName || decl.name;
                        this.pushIdentifierReference(id);
                    }
                }
            }
            else {
                throw new UnsupportedSyntaxError(stmt, `namespace child (walking) not supported yet`);
            }
        }
        this.popScope();
    }
}

class Transformer {
    constructor(sourceFile) {
        this.sourceFile = sourceFile;
        this.fixups = [];
        this.typeReferences = new Set();
        this.declarations = new Map();
        this.exports = new Set();
        // collect all the type references and create fixups to remove them from the code,
        // we will add all of these later on to the whole chunk…
        const lineStarts = sourceFile.getLineStarts();
        for (const ref of sourceFile.typeReferenceDirectives) {
            this.typeReferences.add(ref.fileName);
            const { line } = sourceFile.getLineAndCharacterOfPosition(ref.pos);
            const start = lineStarts[line];
            const end = sourceFile.getLineEndOfPosition(ref.pos);
            this.fixups.push({
                range: { start, end },
                // just overwrite them with whitespace, which will get compressed later on anyway :-)
                replaceWith: " ".repeat(end - start),
            });
        }
        this.ast = createProgram(sourceFile);
        for (const stmt of sourceFile.statements) {
            this.convertStatement(stmt);
        }
    }
    transform() {
        return {
            ast: this.ast,
            fixups: this.fixups,
            typeReferences: this.typeReferences,
        };
    }
    addFixupLocation(range) {
        const original = this.sourceFile.text.slice(range.start, range.end);
        let identifier = `_mp_rt${this.fixups.length}`;
        identifier += original.slice(identifier.length).replace(/[^a-zA-Z0-9_$]/g, () => "_");
        this.fixups.push({
            range,
            replaceWith: identifier,
        });
        return identifier;
    }
    unshiftStatement(node) {
        this.ast.body.unshift(withStartEnd(node, { start: 0, end: 0 }));
    }
    pushStatement(node) {
        this.ast.body.push(node);
    }
    maybeMarkAsExported(node, id) {
        const loc = { start: node.pos, end: node.pos };
        if (!matchesModifier(node, ts.ModifierFlags.Export) || !node.modifiers) {
            return false;
        }
        const isExportDefault = matchesModifier(node, ts.ModifierFlags.ExportDefault);
        const name = isExportDefault ? "default" : id.getText();
        if (this.exports.has(name)) {
            return true;
        }
        this.pushStatement((isExportDefault ? createDefaultExport : createExport)(id, loc));
        this.exports.add(name);
        return true;
    }
    createDeclaration(range, id) {
        if (!id) {
            const scope = new DeclarationScope({ range, transformer: this });
            this.pushStatement(scope.iife);
            return scope;
        }
        const name = id.getText();
        // rollup has problems with functions that are defined twice. For overrides,
        // we can just reuse the already declared function, since overrides are
        // supposed to be declared close to each other…
        // if they are not close to each other, we do have a problem -_-
        let scope = this.declarations.get(name);
        if (!scope) {
            scope = new DeclarationScope({ id, range, transformer: this });
            this.pushStatement(scope.declaration);
            this.declarations.set(name, scope);
        }
        scope.declaration.end = range.end;
        return scope;
    }
    convertStatement(node) {
        if (ts.isEnumDeclaration(node)) {
            return this.convertEnumDeclaration(node);
        }
        if (ts.isFunctionDeclaration(node)) {
            return this.convertFunctionDeclaration(node);
        }
        if (ts.isInterfaceDeclaration(node) || ts.isClassDeclaration(node)) {
            return this.convertClassOrInterfaceDeclaration(node);
        }
        if (ts.isTypeAliasDeclaration(node)) {
            return this.convertTypeAliasDeclaration(node);
        }
        if (ts.isVariableStatement(node)) {
            return this.convertVariableStatement(node);
        }
        if (ts.isExportDeclaration(node) || ts.isExportAssignment(node)) {
            return this.convertExportDeclaration(node);
        }
        if (ts.isModuleDeclaration(node)) {
            return this.convertNamespaceDeclaration(node);
        }
        // istanbul ignore else
        if (ts.isImportDeclaration(node)) {
            return this.convertImportDeclaration(node);
        }
        else {
            throw new UnsupportedSyntaxError(node);
        }
    }
    convertNamespaceDeclaration(node) {
        // we want to keep `declare global` augmentations, and we want to
        // to pull in all the things referenced inside.
        // so for this case, we need to figure out some way so that rollup does
        // the right thing and not rename these…
        const isGlobalAugmentation = node.flags & ts.NodeFlags.GlobalAugmentation;
        if (isGlobalAugmentation) {
            const scope = this.createDeclaration(node);
            scope.convertNamespace(node);
            return;
        }
        // istanbul ignore if
        if (!ts.isIdentifier(node.name)) {
            throw new UnsupportedSyntaxError(node, `namespace name should be an "Identifier"`);
        }
        this.maybeMarkAsExported(node, node.name);
        const scope = this.createDeclaration(node, node.name);
        scope.fixModifiers(node);
        scope.pushIdentifierReference(node.name);
        scope.convertNamespace(node);
    }
    convertEnumDeclaration(node) {
        this.maybeMarkAsExported(node, node.name);
        const scope = this.createDeclaration(node, node.name);
        scope.fixModifiers(node);
        scope.pushIdentifierReference(node.name);
    }
    convertFunctionDeclaration(node) {
        // istanbul ignore if
        if (!node.name) {
            throw new UnsupportedSyntaxError(node, `FunctionDeclaration should have a name`);
        }
        this.maybeMarkAsExported(node, node.name);
        const scope = this.createDeclaration(node, node.name);
        scope.fixModifiers(node);
        scope.pushIdentifierReference(node.name);
        scope.convertParametersAndType(node);
    }
    convertClassOrInterfaceDeclaration(node) {
        // istanbul ignore if
        if (!node.name) {
            throw new UnsupportedSyntaxError(node, `ClassDeclaration / InterfaceDeclaration should have a name`);
        }
        this.maybeMarkAsExported(node, node.name);
        const scope = this.createDeclaration(node, node.name);
        scope.fixModifiers(node);
        const typeVariables = scope.convertTypeParameters(node.typeParameters);
        scope.convertHeritageClauses(node);
        scope.convertMembers(node.members);
        scope.popScope(typeVariables);
    }
    convertTypeAliasDeclaration(node) {
        this.maybeMarkAsExported(node, node.name);
        const scope = this.createDeclaration(node, node.name);
        scope.fixModifiers(node);
        const typeVariables = scope.convertTypeParameters(node.typeParameters);
        scope.convertTypeNode(node.type);
        scope.popScope(typeVariables);
    }
    convertVariableStatement(node) {
        const { declarations } = node.declarationList;
        // istanbul ignore if
        if (declarations.length !== 1) {
            throw new UnsupportedSyntaxError(node, `VariableStatement with more than one declaration not yet supported`);
        }
        for (const decl of declarations) {
            // istanbul ignore if
            if (!ts.isIdentifier(decl.name)) {
                throw new UnsupportedSyntaxError(node, `VariableDeclaration must have a name`);
            }
            this.maybeMarkAsExported(node, decl.name);
            const scope = this.createDeclaration(node, decl.name);
            scope.fixModifiers(node);
            scope.convertTypeNode(decl.type);
        }
    }
    convertExportDeclaration(node) {
        if (ts.isExportAssignment(node)) {
            this.pushStatement(withStartEnd({
                type: "ExportDefaultDeclaration",
                declaration: convertExpression(node.expression),
            }, node));
            return;
        }
        const source = node.moduleSpecifier ? convertExpression(node.moduleSpecifier) : undefined;
        if (!node.exportClause) {
            this.pushStatement(withStartEnd({
                type: "ExportAllDeclaration",
                source,
            }, node));
        }
        else {
            const specifiers = [];
            for (const elem of node.exportClause.elements) {
                specifiers.push(this.convertExportSpecifier(elem));
            }
            this.pushStatement(withStartEnd({
                type: "ExportNamedDeclaration",
                declaration: null,
                specifiers,
                source,
            }, node));
        }
    }
    convertImportDeclaration(node) {
        const source = convertExpression(node.moduleSpecifier);
        const specifiers = node.importClause && node.importClause.namedBindings
            ? this.convertNamedImportBindings(node.importClause.namedBindings)
            : [];
        if (node.importClause && node.importClause.name) {
            specifiers.push({
                type: "ImportDefaultSpecifier",
                local: createIdentifier(node.importClause.name),
            });
        }
        this.pushStatement(withStartEnd({
            type: "ImportDeclaration",
            specifiers,
            source,
        }, node));
    }
    convertNamedImportBindings(node) {
        if (ts.isNamedImports(node)) {
            return node.elements.map(el => {
                const local = createIdentifier(el.name);
                const imported = el.propertyName ? createIdentifier(el.propertyName) : local;
                return {
                    type: "ImportSpecifier",
                    local,
                    imported,
                };
            });
        }
        return [
            {
                type: "ImportNamespaceSpecifier",
                local: createIdentifier(node.name),
            },
        ];
    }
    convertExportSpecifier(node) {
        const exported = createIdentifier(node.name);
        return {
            type: "ExportSpecifier",
            exported: exported,
            local: node.propertyName ? createIdentifier(node.propertyName) : exported,
        };
    }
}

const tsx = /\.tsx?$/;
const plugin = () => {
    // There exists one Program object per entry point,
    // except when all entry points are ".d.ts" modules.
    let programs = [];
    function getModule(fileName) {
        let source;
        let program;
        if (programs.length) {
            // Rollup doesn't tell you the entry point of each module in the bundle,
            // so we need to ask every TypeScript program for the given filename.
            for (program of programs) {
                source = program.getSourceFile(fileName);
                if (source)
                    break;
            }
        }
        // Create any `ts.SourceFile` objects on-demand for ".d.ts" modules,
        // but only when there are zero ".ts" entry points.
        else if (fileName.endsWith(dts)) {
            const code = ts.sys.readFile(fileName, "utf8");
            if (code)
                source = ts.createSourceFile(fileName, code, ts.ScriptTarget.Latest, true);
        }
        return { source, program };
    }
    // Parse a TypeScript module into an ESTree program.
    const typeReferences = new Set();
    function transformFile(input) {
        let code = input.getFullText();
        const transformer = new Transformer(input);
        const output = transformer.transform();
        for (const ref of output.typeReferences) {
            typeReferences.add(ref);
        }
        // apply fixups, which means replacing certain text ranges before we hand off the code to rollup
        for (const fixup of output.fixups) {
            code = code.slice(0, fixup.range.start) + fixup.replaceWith + code.slice(fixup.range.end);
        }
        return { code, ast: output.ast };
    }
    return {
        name: "dts",
        options(options) {
            let { input } = options;
            if (!Array.isArray(input)) {
                input = !input ? [] : typeof input === "string" ? [input] : Object.values(input);
            }
            programs = createPrograms(input);
            return Object.assign(Object.assign({}, options), { treeshake: {
                    moduleSideEffects: "no-external",
                    propertyReadSideEffects: true,
                    unknownGlobalSideEffects: false,
                } });
        },
        outputOptions(options) {
            return Object.assign(Object.assign({}, options), { chunkFileNames: options.chunkFileNames || "[name]-[hash]" + dts, entryFileNames: options.entryFileNames || "[name]" + dts, format: "es", exports: "named", compact: false, freeze: true, interop: false, namespaceToStringTag: false, strict: false });
        },
        load(id) {
            if (!tsx.test(id)) {
                return null;
            }
            if (id.endsWith(dts)) {
                const { source } = getModule(id);
                return source ? transformFile(source) : null;
            }
            // Always try ".d.ts" before ".tsx?"
            const declarationId = id.replace(tsx, dts);
            let module = getModule(declarationId);
            if (module.source) {
                return transformFile(module.source);
            }
            // Generate in-memory ".d.ts" modules from ".tsx?" modules!
            module = getModule(id);
            if (!module.source || !module.program) {
                return null;
            }
            let generated;
            const { emitSkipped, diagnostics } = module.program.emit(module.source, (_, declarationText) => {
                const source = ts.createSourceFile(declarationId, declarationText, ts.ScriptTarget.Latest, true);
                generated = transformFile(source);
            }, undefined, // cancellationToken
            true);
            if (emitSkipped) {
                const errors = diagnostics.filter(diag => diag.category === ts.DiagnosticCategory.Error);
                if (errors.length) {
                    console.error(ts.formatDiagnostics(errors, formatHost));
                    this.error("Failed to compile. Check the logs above.");
                }
            }
            return generated;
        },
        resolveId(source, importer) {
            if (!importer) {
                return;
            }
            // normalize directory separators to forward slashes, as apparently typescript expects that?
            importer = importer.split("\\").join("/");
            // resolve this via typescript
            const { resolvedModule } = ts.nodeModuleNameResolver(source, importer, {}, ts.sys);
            if (!resolvedModule) {
                return;
            }
            // here, we define everything that comes from `node_modules` as `external`.
            // maybe its a good idea to introduce an option for this?
            return resolvedModule.isExternalLibraryImport
                ? { id: source, external: true }
                : // using `path.resolve` here converts paths back to the system specific separators
                    { id: path__default.resolve(resolvedModule.resolvedFileName) };
        },
        renderChunk(code, chunk) {
            const source = ts.createSourceFile(chunk.fileName, code, ts.ScriptTarget.Latest, true);
            const fixer = new NamespaceFixer(source);
            code = Array.from(typeReferences, ref => `/// <reference types="${ref}" />`).join("\n");
            if (code) {
                code += "\n";
            }
            code += fixer.fix();
            return { code, map: { mappings: "" } };
        },
    };
};

exports.default = plugin;
